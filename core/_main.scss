// Copyright (c) 2016 Nicolas Morand (https://twitter.com/NicolasGraph)

// Distributed under the MIT licence (https://opensource.org/licenses/MIT).
// ------------------------------------------------------------------------
// THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
// OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

////
/// @group Main
////

// 1. MIXINS
// 1.1 elsass-group
// 1.2 elsass
// 1.3 elsass-content
// 2. FUNCTIONS
// 2.1 _elsass-bpts-set
// 2.2 _elsass-gutter-silent
// 2.3 _elsass-parse-gutter
// 2.4 _elsass-parse-behaviour
// 2.5 _elsass-parse-offset
// 2.6 _elsass-gutter-css
// 2.7 _elsass-gutter-short
// 2.8 _elsass-merge-bpt
// 2.9 _elsass-list-remove

// 1. MIXIN
// ========

// 1.1 elsass-group
// ----------------
/// Groups multiple `elsass` mixins arguments lists/maps
/// to optimize the output by avoiding duplicated CSS
/// through media-queries.  
/// @param {List} $config -
///   elsass mixin arguments lists/maps (see `elsass`).
/// @example scss - SCSS
///   .foo {
///     border-style: solid;
///     @include elsass-group(
///       ('extra': (border-width: ('gutter': .5)))
///       ('s', 12, 'default')
///       ('m' to 'xl', 6, 'default')
///       (from 'xl', 4, 'default')
///     );
///   }
@mixin elsass-group($config: null) {

  @if $config {
    $elsass-config: map-merge($elsass-config, ('group': true)) !global;

    @each $media in $config {
      @include elsass($media...);
    }
  }

  // Wrap each breakpoint related rules in dedicated media-queries.
  @each $bpt-min, $to-map in $elsass-css {
    @each $bpt-max, $bpt-css in $to-map {
      @include _el-media($bpt-min, $bpt-max) {
        @if type-of($bpt-css) == map {
          #{nth(map-keys($bpt-css), 1)}: nth(map-values($bpt-css), 1);
        } @else if type-of($bpt-css) == list {
          @each $prop in $bpt-css {
            #{nth(map-keys($prop), 1)}: nth(map-values($prop), 1);
          }
        }
      }
    }
  }

  // Reset.
  $elsass-css: null !global;
  $elsass-config: $elsass-config-reset !global;
}

// 1.2 elsass
// ----------
/// Builds any responsive layout element.  
/// Uses global settings before to fallback to responsive ones.  
/// @param {List} $media [from $ELSASS-BPT-MIN] -
///   Defines the related media-query/ies `min`
///   and\or `max-width` from one of the following value:
///   -  `<breakpoint>` applies to the provided breakpoint only;
///   - `from <breakpoint>` applies to the provided breakpoint and larger ones;
///   - `to <breakpoint>` applies to smaller breakpoints than the one provided;
///   - `<breakpoint> to <breakpoint>`.  
///
///   Each value using `from` or `to` allows `<breakpoint>` to be replaced
///   by a `<lenght>` only if no breakpoint settings related value is needed.
/// @param {List} $width -
///   Defines the element `width` and (optionally)
///   `max-witdh` from one of the following values.
///   - `<number>` defines a default columns number related `width`
///     or a `max-width` related to the global/breakpoint(s)
///     container max-width set if followed by `max`;
///   - `<number> of <number>` defines a custom columns number related `width`
///     or a `max-width` related to the global/breakpoint(s)
///     container max-width set if followed by `max`;
///   - `max` set a `max-width` equal to the global/breakpoint(s)
///      container max-width set.
/// @param {List | Map} $gutter -
///   Applies gutters as padding and/or margin based on the following valid values.  
///   - A map, as defined in `$elsass-gutters`;
///   - A shorthand as
///     - `default` uses the default gutter set;
///     - `none` does not apply any gutter;
///     - an `$elsass-gutters` key applies the related value;
///     - an `$elsass-behaviours` key applies the related change(s)
///       to alterate the default gutter;
///     - an `$elsass-gutters` key followed by an `$elsass-behaviours` key
///       applies the `$elsass-behaviours` related change(s) to alterate
///       the `$elsass-gutters` related value.  
///
///     `$elsass-behaviours` keys accept suffixes to alterate defined gutter sides.
///     Valid sufixes are `-top`, `-right`, `-bottom`, `-left`, `-x` and `-y`.  
///     If no suffix is provided all gutter related sides will be alterate.
/// @param {List | Map} $offset -
///   Alterates the horizontal element and/or content position
///   via margin and/or padding through the following values.
///   - A map of `in` and/or `out` offset values as:
///     - a map of sides related or grid fraction or `<length>`;
///   - A shorthand using a list of `$elsass-offsets` keys
///     optionally followed by a related grid fraction or `<length>`.
///     If no ratio is provided `auto` will be used as the padding/margin value.
/// @param {List | Map} $extra -
///   List of extra CSS rules to apply.  
///   Gutter or width related CSS values can be indirectly set
///   by providing a map using `gutter` or `width` as key and
///   a list or map of the `elsass-gutter` or `elsass-width`
///   function arguments as value.
/// @output Arguments and `@content` relative CSS wrapped into tidy media-queries.
/// @example scss - SCSS
///   .foo {
///     border-style: solid;
///     @include elsass('m', 6, 'after', 'before' 3, (border-width: ('gutter': 1)));
///   }
@mixin elsass(
  $media : 'from' $ELSASS-BPT-MIN,
  $width : null,
  $gutter: null,
  $offset: null,
  $extra : null
) {

  // Get the provided breakpoints.
  $media: _elsass-parse-media($media);
  $elsass-config: map-merge($elsass-config, $media) !global;
  $bpts-set: _elsass-bpts-set($media...);
  $elsass-config: map-merge($elsass-config, ('bpts': $bpts-set)) !global;

  $bpt-width: null;
  $max-width: null;

  @if $width {
    $bpt-width: nth($width, 1);

    @if type-of($width) == list {
      @if length($width) >= 3 {
        $elsass-config: map-merge($elsass-config, ('cols': nth($width, 3))) !global;
      }
      @if length($width) == 2 or length($width) == 4 {
        $max-width: $bpt-width 'max';
        $bpt-width: null;
      }
    } @else if type-of($width) == string {
      $max-width: 'max';
      $bpt-width: null;
    } @else if type-of($width) != number {
      $max-width: $bpt-width 'max';
      $bpt-width: null;
    }
  }

  $gutter-in: null;
  $gutter-out: null;
  $silent: null;
  $gutter-width: false;

  @if $gutter {
    $gutters: if($gutter == 'none', (), _elsass-parse-gutter($gutter));
    @if map-has-key($gutters, 'in') {
      $gutter-in: map-get($gutters, 'in');
    }
    @if map-has-key($gutters, 'out') {
      $gutter-out: map-get($gutters, 'out');
    } @else {
      $silent: true;
      $gutter-out: map-get($gutters, 'silent');
    }

    @if $gutter-out {
      @each $val in (map-get($gutter-out, 'right'), map-get($gutter-out, 'left')) {
        @if $val {
          $gutter-width: if($gutter-width, append($gutter-width, $val), $val);
          $elsass-config: map-merge($elsass-config, ('g-width': $gutter-width)) !global;
        }
      }
    }
  }

  $offset-in: null;
  $offset-out: null;

  @if $offset {
    $offsets: _elsass-parse-offset($offset);
    @if map-has-key($offsets, 'out') {
      $offset-out: map-get($offsets, 'out');
    }
    @if map-has-key($offsets, 'in') {
      $offset-in: map-get($offsets, 'in');
    }
  }

  $out: null;

  // Get and store each breakpoint related CSS.
  @each $bpt in $bpts-set {

    $elsass-config: map-merge($elsass-config, ('bpt': $bpt)) !global;

    $bpt-css: () !global;

    @if $bpt-width {
      @if $gutter-out or $gutter-in {
        $bpt-css: append($bpt-css, (box-sizing: border-box)) !global;
      }
      $val: elsass-width($bpt-width, if($gutter-width, $gutter-width, false));
      $bpt-css: append($bpt-css, (width: #{$val})) !global;
    }

    @if $max-width {
      $val: elsass-width($max-width, if($gutter-width, $gutter-width, false));
      $bpt-css: append($bpt-css, (max-width: #{$val})) !global;
    }

    @if $gutter-in or $offset-in {
      $bpt-gutter: _elsass-gutter-css($gutter-in, false, $offset-in);
      @if map-has-key($bpt-gutter, 'shorthand') {
        $shorthand: map-get($bpt-gutter, 'shorthand');
        $bpt-css: append($bpt-css, (padding: #{$shorthand})) !global;
      } @else {
        @each $side, $val in $bpt-gutter {
          $bpt-css: append($bpt-css, (padding-#{$side}: #{$val})) !global;
        }
      }
    }

    @if $gutter-out or $offset-out {
      $bpt-gutter: _elsass-gutter-css($gutter-out, $silent, $offset-out);
      @if map-has-key($bpt-gutter, 'shorthand') {
        $shorthand: map-get($bpt-gutter, 'shorthand');
        $bpt-css: append($bpt-css, (margin: #{$shorthand})) !global;
      } @else {
        @each $side, $val in $bpt-gutter {
          $bpt-css: append($bpt-css, (margin-#{$side}: #{$val})) !global;
        }
      }
    }

    @if $extra {
      @if type-of($extra) == map {
        $vals: nth(map-values($extra), 1);
        @if type-of($vals) != list {
          $vals: ($vals) ();
        }
        $new: null;
        @each $val in $vals {
          @if type-of($val) == map {
            @if map-has-key($val, 'gutter') {
              $val: elsass-gutter(map-get($val, 'gutter')...);
            } @else {
              $val: elsass-width(map-get($val, 'width')...);
            }
          }
          $new: if($new, $new $val, $val);
        }
        $bpt-css: if($new, append($bpt-css, (nth(map-keys($extra), 1): $new)), append($bpt-css, $extra)) !global;
      } @else if type-of($extra) == list {
        @each $prop in $extra {
          $new: null;
          @each $val in map-values($prop) {
            @if type-of($val) == map {
              @if map-has-key($val, 'gutter') {
                $val: elsass-gutter(map-get($val, 'gutter'));
              } @else {
                $val: elsass-width(map-get($val, 'width'));
              }
            }
            $new: if($new, $new $val, $val);
          }
          $bpt-css: if($new, append($bpt-css, (nth(map-keys($prop), 1): $new)), append($bpt-css, $prop)) !global;

        }
      }
    }

    // Prepare the output.
    $bpt-next: false;
    $i: index($bpts-set, $bpt);

    @if $i == length($bpts-set) {
      @if map-get($media, 'to') {
        $bpt-next: nth($ELSASS-BPTS, index($ELSASS-BPTS, $bpt) + 1);
      }
    } @else {
      $bpt-next: nth($bpts-set, $i + 1);
    }

    $bpt-map: ($bpt: ($bpt-next: $bpt-css));
    $elsass-css: if($elsass-css, _elsass-merge-bpt($elsass-css, $bpt-map), $bpt-map) !global;
  }

  @if not _elsass-config('group') {
    @include elsass-group;
  }
}

// 2. FUNCTIONS
// ============

// 2.1 _elsass-bpts-set
// --------------------
/// Get a list of breakpoints
/// explicitly and implicitly set.
/// @param {Breakpoint} $from;
/// @param {Breakpoint} $to;
/// @return {List | false} Breakpoints list | false;
/// @example scss -
///   _elsass-bpts-set('s', 'l')
///   // Assuming valid bpts are 's', 'm', 'l' and 'xl';
///   // 's' 'm' 'l'
@function _elsass-bpts-set($from: null, $to: null) {
  $out: false;
  $i-from: if($from, index($ELSASS-BPTS, $from), 1);
  $i-to: if($to, index($ELSASS-BPTS, $to), length($ELSASS-BPTS));

  @for $i from $i-from through $i-to {
    @if not $to or $i != index($ELSASS-BPTS, $to) {
      $bpt: nth($ELSASS-BPTS, $i);
      $out: if($out, append($out, $bpt), $bpt);
    }
  }

  @return $out;
}

// 2.2 _elsass-gutter-silent
// -------------------------
/// Returns a map of needed flex related
/// CSS properties and their values.
/// @param {â€¦} $gutter CSS flex-wrap value;
/// @return {List | false} Silent gutter value | false.
@function _elsass-gutter-silent($gutter: null) {
  $out: false;

  @if $gutter == 'silent' {
    $out: _elsass-setting('gutter');
  } @else if type-of($gutter) == map and map-has-key($gutter, 'silent') {
    $out: map-get($gutter, 'silent');
  }

  @return $out;
}

// 2.3 _elsass-parse-gutter
// ----------------------
/// Return a map of side values from the elsass mixin $gutter value.
/// @param {List} $gap -
///   Single value or list of two or four values;
/// @return {Map | false} Map of side values | false.
/// @example scss -
///   _elsass-parse-gutter(false .5);
///   // (top: false, left: .5, bottom: false, $right: .5)
@function _elsass-parse-gutter($gutter: null) {
  $silent: null;
  $behaviour: null;

  // Parse keywords.
  @if type-of($gutter) == string or type-of($gutter) == list {
    $type: nth($gutter, 1);

    @if not map-has-key($ELSASS-GUTTERS, $type) {
      @if $type == 'default' {
        $type: _elsass-setting('gutter');
      } @else {
        $behaviour: $type;
        $type: _elsass-setting('gutter');
      }
    } @else if type-of($gutter) == list {
      $behaviour: nth($gutter, 2);
    }

    // Assign values according to $type.
    @if type-of($type) == string {
      $gutter: map-get($ELSASS-GUTTERS, $type);
    } @else {
      $gutter: $type;
    }
  }

  // Get gutters map.
  $out: false;

  @each $pos, $vals in $gutter {

    @if not $silent and $pos == 'out' and _elsass-gutter-silent($vals) {
      $silent: true;
      $vals: _elsass-gutter-silent($vals);
    }

    // Get a four values list from one to four values.
    @if type-of($vals) == number {
      $vals: $vals $vals $vals $vals;
    } @else if type-of($vals) == list {
      @if length($vals) == 2 {
        $vals: nth($vals, 1) nth($vals, 2) nth($vals, 1) nth($vals, 2);
      } @else if length($vals) == 3 {
        $vals: nth($vals, 1) nth($vals, 2) nth($vals, 3) nth($vals, 2);
      }
    }

    // Get a map of sides values.
    @if type-of($vals) == list {
      @each $side in $ELSASS-SIDES {
        $i: index($ELSASS-SIDES, $side);
        $val: nth($vals, $i);
        @if type-of($val) == number {
          $merge: ($side: $val);
          @if $out {
            @if map-has-key($out, $pos) {
              $out: map-merge($out, ($pos: _elsass-map-merge(($out, $pos), $merge)));
            } @else {
              $out: map-merge($out, ($pos: $merge));
            }
          } @else {
            $out: ($pos: $merge);
          }
        }
      }
    } @else {
      $out: ($pos: $vals);
    }
  }

  // Alterate gutters according $behaviour.
  @if $out and $behaviour {
    $out: _elsass-parse-behaviour($out, $behaviour);
  }

  @return $out;
}

// 2.4 _elsass-parse-behaviour
// ---------------------------
/// Alterate a map of sides related gutter values
/// according to a define behaviour.
/// @param {Map} $gutter -
///   Map of sides related gutter values;
/// @param {String} $behaviour -
///   Behaviour related keyword;
/// @return {Map} New map of sides related gutter values.
@function _elsass-parse-behaviour($gutter, $behaviour) {
  $out: $gutter;
  $new: null;

  $dash: str_index($behaviour, '-');
  $kw: $behaviour;
  $sides: $ELSASS-SIDES;
  
  @if $dash {
    $sides: str_slice(#{$kw}, $dash + 1);
    @if $sides == 'x' {
      $sides: 'right' 'left';
    } @else if $sides == 'y' {
      $sides: 'top' 'bottom';
    }
    $kw: str_slice(#{$kw}, 1, $dash - 1);
  }

  $gutter-pos: 'out';

  @if map-has-key($gutter, 'in') and map-has-key($gutter, 'out') {
    $gutter-pos: 'in-out';
  } @else if map-has-key($gutter, 'in') {
    $gutter-pos: 'in';
  }

  $to: _elsass-map-get($ELSASS-BEHAVIOURS, $kw, $gutter-pos);

  // Alterate values.
  @if $to == 'silent' {
    $out: ('silent': map-get($gutter, 'out'));
  } @else {
    @each $pos, $vals in $to {
      $map: ();
      @each $side in $sides {
        $map: map-merge($map, ($side: $vals));
      }
      $vals: $map;

      $new: ();

      @each $side, $val in $vals {
        $from: null;
        $base: null;
        $alt: $val;
        @if type-of($val) == list {
          $from: nth($val, 1);
          $alt: nth($val, 2);
          @if _elsass-map-get($gutter, $from, $side) {
            $base: _elsass-map-get($gutter, $from, $side);
            $new: map-merge($new, ($side: $base * $alt));
          }
        } @else {
          @if _elsass-map-get($gutter, $pos, $side) {
            @if $val == 'none' {
              $gutter: map-merge($gutter, ($pos: map-remove(map-get($gutter, $pos), $side)));
            } @else {
              $new: map-merge($new, ($side: $alt));
            }
          }
        }
      }
      $merge: if(map-has-key($gutter, $pos), map-get($gutter, $pos), null);
      $alt: ($pos: if($merge, _elsass-map-merge(($gutter, $pos), $new), $new));
      $out: if($out, map-merge($out, $alt), $alt);
    }
    $out: map-merge($gutter, $out);
  }

  @return $out;
}

// 2.5 _elsass-parse-offset
// ---------------------
/// Returns a map of needed flex related
/// CSS properties and their values.
/// @access  Private
/// @param {Map | List} $offset;
/// @return {Map | false} Map of offset value(s) per side | false.
@function _elsass-parse-offset($offset: null) {
  $out: false;

  @if type-of($offset) == map {
    @each $pos, $vals in $offset {
      @if type-of($vals) == number {
        $vals: $vals $vals;
      }
      @if type-of($vals) == list {
        @each $side in ('left', 'right') {
          $i: index(('left', 'right'), $side);
          $val: nth($vals, $i);
          @if $val {
            @if $out {
              @if map-has-key($out, $pos) {
                $pos: ($pos: _elsass-map-merge(($out, $pos), ($side: $val)));
                $out: map-merge($out, $pos);
              } @else {
                $out: map-merge($out, ($pos: ($side: $val)));
              }
            } @else {
              $out: ($pos: ($side: $val));
            }
          }
        }
      } @else {
        $out: $offset;
      }
    }
  } @else {
    // Parse keywords.
    $new: null;

    $i: 1;
    @while $i <= length($offset) {
      $kw: nth($offset, $i);
      $val: null;

      @if $i < length($offset) and type-of(nth($offset, $i + 1)) == number {
        $val: nth($offset, $i + 1);
        $i: $i + 2;
      } @else {
        $val: auto;
        $i: $i + 1;
      }

      $pos: nth(map-keys(map-get($ELSASS-OFFSETS, $kw)), 1);
      @if $new and not map-has-key($new, $pos) {
        $new: map-merge($new, ($pos: null));
      } @else if not $new {
        $new: ($pos: null);
      }

      @each $side in _elsass-map-get($ELSASS-OFFSETS, $kw, $pos) { 
        @if map-get($new, $pos) {
          $new: map-merge($new, ($pos: _elsass-map-merge(($new, $pos), ($side: $val))));
        } @else {
          $new: map-merge($new, ($pos: ($side: $val)));
        }
      }
    }
    $out: $new;
  }

  @return $out;
}

// 2.6 _elsass-gutter-css
// ----------------------
/// Returns a map of needed flex related
/// CSS properties and their values.
/// @param {Breakpoint | Ratio | Lentgth} $gutter
///   Breakpoint related gutter ratio(s) or CSS value(s);
/// @param {Ratio} $offset;
/// @param {Bool} $offset-next;
/// @return {Map | false} Map of side values | false.
@function _elsass-gutter-css(
  $gutter : null,
  $silent : null,
  $offset : null
) {
  $out: ();
  $shorthand: null;

  // Get a map of each margin side value.
  $vals: ();

  @each $side in $ELSASS-SIDES {
    @if not $silent or ($offset and map-has-key($offset, $side)) { 
      $off: if($offset, map-get($offset, $side), false);
      $gutter-val: if($gutter, map-get($gutter, $side), false);
      $val: null;
      @if $off == auto {
        $val: $off;
      } @else {
        $val: elsass-gutter(if($gutter-val, $gutter-val, false), $off);
      }
      $vals: map-merge($vals, ($side: $val));
    }
  }

  $shorthand: _elsass-gutter-short($vals...);

  @if $shorthand {
    $out: map-merge($out, ('shorthand': $shorthand));
  } @else {
    @each $side in $ELSASS-SIDES {
      $val: map-get($vals, $side);
      @if $val != false {
        $out: map-merge($out, (#{$side}: $val));
      }
    }
  }

  @return $out;
}

// 2.7 _elsass-gutter-short
// ------------------------
/// Returns a padding/margin shorthand value if possible.
/// @param {Number} $top - Top gutter length.
/// @param {Number} $right - Right gutter length.
/// @param {Number} $bottom - Bottom gutter length.
/// @param {Number} $left - Left gutter length.
/// @return {Number | false} Shorthand value | false.
@function _elsass-gutter-short(
  $top   : null,
  $right : null,
  $bottom: null,
  $left  : null
) {
  $out: false;

  @if $top and $top == $bottom and $right and $right == $left {
    $out: if($top == $right, $top, $top $right);
  }

  @return $out;
}

// 2.8 _elsass-merge-bpt
// ---------------------
/// Merge map of CSS stored per media-queries related
/// breakpoints in a way to optimize the outpout.
/// @param {Map} $out
///   Map of CSS stored per media-queries relative breakpoints;
/// @param {Map} $map
///   Map of the following breapoint CSS;
/// @return {Map} Map of CSS per media-queries.
/// @example scss -
///   $out: (s: (m: (width: 25%, margin: 10px)));
///   $bpt-map: (m: (l: (width: 25%, margin: 15px)));
///   elsass-merge($out, $bpt-map);
///   // (s: (m: (margin: 10px), l: (width: 25%)),
///   //  m: (l: (margin: 15px)));
@function _elsass-merge-bpt($out, $bpt-map) {
  $new-css: ();

  $bpt: nth(map-keys($bpt-map), 1);
  $submap: map-get($bpt-map, $bpt);
  $bpt-next: nth(map-keys($submap), 1);
  $bpt-css: map-get($submap, $bpt-next);
  $map-from: null;

  @each $bpt-prop in $bpt-css {
    @each $bpt-from, $map-to in $out {
      @if map-has-key($map-to, $bpt) {
        $to-css: map-get($map-to, $bpt);
        @if index($to-css, $bpt-prop) {
          // Remove duplicated CSS.
          $bpt-css: _elsass-list-remove($bpt-css, $bpt-prop);
          $to-css: _elsass-list-remove($to-css, $bpt-prop);
          // Move duplicated CSS in an extended media-query.
          $new-css: append($new-css, $bpt-prop);
          $new-map-to: ($bpt: $to-css, $bpt-next: $new-css);
          $map-to: _elsass-map-merge(($out, $bpt-from), $new-map-to);

          $out: map-merge($out, ($bpt-from: ($map-to)));
        }
      }
    }
  }

  @if map-has-key($out, $bpt) {
    $map-to: map-get($out, $bpt);
    $new-map-to: null;
    @if map-has-key($map-to, $bpt-next) {
      $to-css: map-get($map-to, $bpt-next);
      @each $bpt-prop in $bpt-css {
        @if index($to-css, $bpt-prop) {
          $bpt-css: _elsass-list-remove($bpt-css, $bpt-prop);
        }
      }
      $new-map-to: map-merge($map-to, ($bpt-next: join($to-css, $bpt-css)));
    } @else {
      $new-map-to: map-merge($map-to, ($bpt-next: $bpt-css));
    }
    $out: map-merge($out, ($bpt: ($new-map-to)));
  } @else {
    $out: map-merge($out, ($bpt: ($bpt-next: $bpt-css)));
  }

  @return $out;
}

// 2.9 _elsass-list-remove
// -----------------------
/// Remove from list.
/// @param {List} $list
///   List from which the value need to be removed.
/// @param {Value} $value
///   Value to remove from the list.
/// @return {List}
@function _elsass-list-remove($list, $value) {
  $result: ();

  @for $i from 1 through length($list) {
    @if nth($list, $i) != $value {
      $result: append($result, nth($list, $i));
    }
  }

  @return $result;
}
